// src/hooks/analytics/useAnalyticsData.ts

// React 19.1 optimizes automatically - useMemo removed
import {usePolicies} from '../policies';
import {useCommissions} from '../commissions';
import {useExpenses} from '../expenses';
import {useCarriers} from '../carriers';
import {getCohortRetention, getChargebacksByCohort, getEarningProgressByCohort, getCohortSummary, segmentClientsByValue, calculateCrossSellOpportunities, getClientLifetimeValue, forecastRenewals, calculateChargebackRisk, projectGrowth, detectSeasonality, calculateContribution, getProductMixEvolution, calculateCarrierROI, getTopMovers} from '../../services/analytics';

export interface UseAnalyticsDataOptions {
  startDate?: Date;
  endDate?: Date;
}

/**
 * Centralized analytics data aggregation hook
 *
 * Combines all analytics services with TanStack Query data fetching.
 * All calculations are memoized for performance.
 *
 * @param options - Optional date range filter
 * @returns Comprehensive analytics data object
 */
export function useAnalyticsData(options?: UseAnalyticsDataOptions) {
  const { startDate, endDate } = options || {};

  // Fetch all required data from Supabase
  const { data: allPolicies = [], isLoading: policiesLoading } = usePolicies();
  const { data: allCommissions = [], isLoading: commissionsLoading } = useCommissions();
  const { data: expenses = [], isLoading: expensesLoading } = useExpenses();
  const { data: carriers = [], isLoading: carriersLoading } = useCarriers();

  // Filter data by date range if provided (React 19.1 optimizes automatically)
  const policies = (!startDate || !endDate) ? allPolicies : allPolicies.filter(p => {
    const date = new Date(p.effectiveDate);
    return date >= startDate && date <= endDate;
  });

  const commissions = (!startDate || !endDate) ? allCommissions : allCommissions.filter(c => {
    const date = new Date(c.createdAt);
    return date >= startDate && date <= endDate;
  });

  // Calculate loading state
  const isLoading = policiesLoading || commissionsLoading || expensesLoading || carriersLoading;

  // Cohort Analysis - all cohort-related metrics (React 19.1 optimizes automatically)
  const cohortData = {
    retention: getCohortRetention(policies),
    chargebacks: getChargebacksByCohort(policies, commissions),
    earningProgress: getEarningProgressByCohort(policies, commissions),
    summary: getCohortSummary(policies, commissions),
  };

  // Client Segmentation - client value and opportunities (React 19.1 optimizes automatically)
  const segmentationData = {
    segments: segmentClientsByValue(policies),
    crossSell: calculateCrossSellOpportunities(policies),
    ltv: getClientLifetimeValue(policies),
  };

  // Predictive Analytics - forecasting and risk (React 19.1 optimizes automatically)
  const forecastData = {
    renewals: forecastRenewals(policies),
    chargebackRisk: calculateChargebackRisk(policies, commissions),
    growth: projectGrowth(policies, commissions),
    seasonality: detectSeasonality(policies),
  };

  // Performance Attribution - decomposition analysis
  // Split policies/commissions into current month and previous month for comparison
  const now = new Date();
  const currentMonth = new Date(now.getFullYear(), now.getMonth(), 1);
  const previousMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);

  // React 19.1 optimizes automatically - no need for useMemo
  const currentPolicies = policies.filter(p => new Date(p.effectiveDate) >= currentMonth);

  const previousPolicies = policies.filter(p => {
    const date = new Date(p.effectiveDate);
    return date >= previousMonth && date < currentMonth;
  });

  const currentCommissions = commissions.filter(c => new Date(c.createdAt) >= currentMonth);

  const previousCommissions = commissions.filter(c => {
    const date = new Date(c.createdAt);
    return date >= previousMonth && date < currentMonth;
  });

  // React 19.1 optimizes automatically - no need for useMemo
  const attributionData = {
    contribution: calculateContribution(currentPolicies, currentCommissions, previousPolicies, previousCommissions),
    productMix: getProductMixEvolution(policies),
    carrierROI: calculateCarrierROI(policies, commissions, carriers),
    topMovers: getTopMovers(currentPolicies, currentCommissions, previousPolicies, previousCommissions, carriers),
  };

  return {
    isLoading,
    cohort: cohortData,
    segmentation: segmentationData,
    forecast: forecastData,
    attribution: attributionData,
    // Raw data for custom calculations
    raw: {
      policies,
      commissions,
      expenses,
      carriers,
    },
  };
}
